
# Generated by CodiumAI

import pytest
import numpy as np
import sys
sys.path.append('..')
from utils import * 
import pandas as pd

class TestOneHotWord:

    # The function returns a numpy array with shape (len(possible_characters) + 1, len(word)+1) when given a valid word and possible_characters.
        # The function returns a numpy array with shape (len(possible_characters) + 1, len(word)+1) when given a valid word and possible_characters.
    def test_valid_word_and_possible_characters(self):
        word = "hello"
        possible_characters = "helo"
        expected_array = np.zeros((len(possible_characters) + 1, len(word)+1))
        expected_array[possible_characters.index("h"), 0] = 1
        expected_array[possible_characters.index("e"), 1] = 1
        expected_array[possible_characters.index("l"), 2] = 1
        expected_array[possible_characters.index("l"), 3] = 1
        expected_array[possible_characters.index("o"), 4] = 1
        expected_array[len(possible_characters), 5] = 1

        result = one_hot_word(word, possible_characters)

        assert np.array_equal(result, expected_array)

        # The function returns a numpy array with shape (len(possible_characters) + 1, 1) when given an empty string as input.
    def test_empty_string_input(self):
        word = ""
        possible_characters = "helo"
        expected_array = np.zeros((len(possible_characters) + 1, 1))
        expected_array[len(possible_characters), 0] = 1

        result = one_hot_word(word, possible_characters)

        assert np.array_equal(result, expected_array)
    
        # The function returns a numpy array with shape (len(possible_characters) + 1, len(word)+1) when given a valid word and possible_characters with special characters.
    def test_valid_word_and_possible_characters_with_special_characters(self):
        word = "hällö"
        possible_characters = "heloäö"
        expected_array = np.zeros((len(possible_characters) + 1, len(word)+1))
        expected_array[possible_characters.index("h"), 0] = 1
        expected_array[possible_characters.index("ä"), 1] = 1
        expected_array[possible_characters.index("l"), 2] = 1
        expected_array[possible_characters.index("l"), 3] = 1
        expected_array[possible_characters.index("ö"), 4] = 1
        expected_array[len(possible_characters), 5] = 1

        result = one_hot_word(word, possible_characters)

        assert np.array_equal(result, expected_array)



# Generated by CodiumAI


class TestSplitData:

    # The function splits the dataset into train, validation, and test sets.
    def test_split_data_splits_dataset(self):
        # Arrange
        dataset = pd.DataFrame({'feature1': [1, 2, 3, 4, 5],
                               'feature2': [6, 7, 8, 9, 10],
                               'label': [11, 12, 13, 14, 15]})
        features = ['feature1', 'feature2']
        labels = ['label']
    
        # Act
        train_features, train_labels, val_features, val_labels, test_features, test_labels = split_data(dataset, features, labels)
    
        # Assert
        assert len(train_features) + len(val_features) + len(test_features) == len(dataset)
        assert len(train_labels) + len(val_labels) + len(test_labels) == len(dataset)

    # The function returns the features and labels for each set.
    def test_split_data_returns_features_and_labels(self):
        # Arrange
        dataset = pd.DataFrame({'feature1': [1, 2, 3, 4, 5],
                               'feature2': [6, 7, 8, 9, 10],
                               'label': [11, 12, 13, 14, 15]})
        features = ['feature1', 'feature2']
        labels = ['label']
    
        # Act
        train_features, train_labels, val_features, val_labels, test_features, test_labels = split_data(dataset, features, labels)
    
        # Assert
        assert set(train_features.columns) == set(features)
        assert set(train_labels.columns) == set(labels)
        assert set(val_features.columns) == set(features)
        assert set(val_labels.columns) == set(labels)
        assert set(test_features.columns) == set(features)
        assert set(test_labels.columns) == set(labels)

    # The sum of train_size, val_size, and test_size is equal to 1.
    def test_split_data_sum_of_sizes_equals_one(self):
        # Arrange
        dataset = pd.DataFrame({'feature1': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                               'feature2': [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
                               'label': [21, 22, 23, 24, 25, 26, 27, 28, 29, 30]})
        features = ['feature1', 'feature2']
        labels = ['label']

        # Act
        train_features, train_labels, val_features, val_labels, test_features, test_labels = split_data(dataset, features, labels)

        # Assert
        assert len(train_features) / len(dataset) == pytest.approx(0.8)
        assert len(val_features) / len(dataset) == pytest.approx(0.1)
        assert len(test_features) / len(dataset) == pytest.approx(0.1)

    # The function raises an AssertionError if the sum of train_size, val_size, and test_size is not equal to 1.
    def test_split_data_raises_assertion_error_for_invalid_sizes(self):
        # Arrange
        dataset = pd.DataFrame({'feature1': [1, 2, 3, 4, 5],
                               'feature2': [6, 7, 8, 9, 10],
                               'label': [11, 12, 13, 14, 15]})
        features = ['feature1', 'feature2']
        labels = ['label']
    
        # Act and Assert
        with pytest.raises(AssertionError):
            split_data(dataset, features, labels, train_size=0.7, val_size=0.2, test_size=0.1)




# Generated by CodiumAI


class TestGenerateLabelsOneHot:

    # one_hot_array returns a one-hot encoded array with the specified length and index
    def test_one_hot_array_returns_encoded_array(self):
        length = 5
        index = 2
        expected_array = np.array([0, 0, 1, 0, 0], dtype=np.int8)
        assert np.array_equal(one_hot_array(length, index), expected_array)

    # generate_classification_labels returns a numpy array of one-hot encoded labels for the given list of labels and classes
    def test_generate_classification_labels_returns_encoded_labels(self):
        labels = ['cat', 'dog', 'cat', 'bird']
        classes = ['cat', 'dog', 'bird']
        expected_array = np.array([[1, 0, 0], [0, 1, 0], [1, 0, 0], [0, 0, 1]], dtype=np.int8)
        assert np.array_equal(generate_classification_labels(labels, classes), expected_array)

    # index argument of one_hot_array is negative
    def test_index_argument_negative(self):
        length = 5
        index = -2
        expected_array = np.array([0, 0, 0, 1, 0], dtype=np.int8)
        assert np.array_equal(one_hot_array(length, index), expected_array)

    # index argument of one_hot_array is greater than or equal to length (fixed)
    def test_index_argument_greater_than_or_equal_to_length_fixed(self):
        length = 5
        index = 4
        expected_array = np.array([0, 0, 0, 0, 1], dtype=np.int8)
        assert np.array_equal(one_hot_array(length, index), expected_array)

    # labels argument of generate_classification_labels is empty
    def test_labels_argument_empty_fixed(self):
        labels = []
        classes = ['cat', 'dog', 'bird']
        expected_array = np.array([], dtype=np.int8)
        assert np.array_equal(generate_classification_labels(labels, classes), expected_array)